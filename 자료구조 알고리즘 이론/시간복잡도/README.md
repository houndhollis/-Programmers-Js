# Big-O
> 알고리즘의 성능을 수학적으로 표현한것
알고리즘의 시간과 공간복잡도를 표기가능,알고리즘의 성능을 예측하는것이 목표이다.

## O(1)
- 입력데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘이다.
```
function(n){
    n === true? true:false 
    // 같은 느낌인듯 하다.
}
```
> O(n)
- 입력 데이터에 크기에 비래해서 처리 속도가 걸리는 알고리즘이다.
```
function(n){
    for(let i = 0; i<n; i++){
        console.log(i)
    }
}
```
언제나 데이터와 시간이 같은 비율로 증가하기 때문에 그래프는 직선이다

> O(n2)
- 함수안에서 n을 그안에서 n으로 루프를 또돌릴떄 엔 스퀘어가 된다.
- n이 하나 늘어날때마다 데이터가 커지면 커질수록 처리속도에 부담이 커진다. 
- 처음에는 조금씩 상승하다가 나중에는 수직적으로 상승한다

>O(nm)
- n 을 m만큼 돌리는것이다. 
- 데이터가 증가할 수록 그래프가 수직에 가까운 모양이된다.

>O(n3)
- n의 제곱에 한번을 더돌려서 세제곱으로 돌리는 것이다.
- n의 세제곱은 n제곱이랑 비슷한 그래프를 보이지만 더 급격하다

>O(log n)
- 대표적인 알고리즘은 이진검색이다.
- 한번 처리가 진행될때마다 검색해야하는 데이터의 양이 절반씩 떨어지는 것이 로그엔 알고리즘이다.
- O(n) 보다도 성능이 크게 차이나지않고 데이터가 증가해도 빠른편이다.

>O(sqrt(n))
```
1 2 
3 4 
// 4까지 적었을 경우 맨위에 2개가 4의 제곱근이다 그럼
// 9의 경우를 보면

1 2 3 
4 5 6
7 8 9 
// 이렇게 9같은 경우도 맨위에 3개가 즉 9의 제곱근이다
```
- 빅오표기 법은 실제 알고리즘의 러닝 타임을 재는것이 아니라
- 처리시간의 증가율을 예측하기 위해 만들어 진것이다.
- O(2n)도 가능 O(n) 이다, 상수는 중요하지 않다



